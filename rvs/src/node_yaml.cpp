#include <yaml.h>
#include <cstdio>
#include <cstdlib>
#include <string>
#include <cerrno>
#include <iostream>
#include <vector>
#include <map>
#include "include/node_yaml.h"
/* Set environment variable DEBUG=1 to enable debug output. */
int debug = 0;


/*
 * Consume yaml events generated by the libyaml parser to
 * import our data into raw c++ data structures.
 */
int consume_event(struct parser_state *&s, yaml_event_t *event)
{
    char *value;
    std::string temp;
    std::string key;
    ActionMap f;
    if (debug) {
        printf("state=%d event=%d\n", s->state, event->type);
    }
    switch (s->state) {
    case STATE_START:
        switch (event->type) {
        case YAML_STREAM_START_EVENT:
            s->state = STATE_STREAM;
            break;
        default:
            fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
            return FAILURE;
        }
        break;

     case STATE_STREAM:
        switch (event->type) {
        case YAML_DOCUMENT_START_EVENT:
            s->state = STATE_DOCUMENT;
            break;
        case YAML_STREAM_END_EVENT:
            s->state = STATE_STOP;  /* All done. */
            break;
        default:
            fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
            return FAILURE;
        }
        break;

     case STATE_DOCUMENT:
        switch (event->type) {
        case YAML_MAPPING_START_EVENT:
            s->state = STATE_SECTION;
            break;
        case YAML_DOCUMENT_END_EVENT:
            s->state = STATE_STREAM;
            break;
        default:
            fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
            return FAILURE;
        }
        break;

    case STATE_SECTION:
        switch (event->type) {
        case YAML_SCALAR_EVENT:
            value = (char *)event->data.scalar.value;
            if (strcmp(value, ACTIONS.c_str()) == 0) {
               s->state = STATE_ACTIONLIST;
            } else {
               fprintf(stderr, "Unexpected scalar: %s\n", value);
               return FAILURE;
            }
            break;
        case YAML_DOCUMENT_END_EVENT:
            s->state = STATE_STREAM;
            break;
        default:
            fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
            return FAILURE;
        }
        break;

    case STATE_ACTIONLIST:
        switch (event->type) {
        case YAML_SEQUENCE_START_EVENT:
            s->state = STATE_ACTIONVALUES;
            break;
        case YAML_MAPPING_END_EVENT:
            s->state = STATE_SECTION;
            break;
        default:
            fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
            return FAILURE;
        }
        break;

    case STATE_ACTIONVALUES:
        switch (event->type) {
        case YAML_MAPPING_START_EVENT:
            s->state = STATE_ACTIONKEY;
            break;
        case YAML_SEQUENCE_END_EVENT:
            s->state = STATE_ACTIONLIST;
            break;
        default:
            fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
            return FAILURE;
        }
        break;

    case STATE_ACTIONKEY:
        switch (event->type) {
        case YAML_SCALAR_EVENT:
            // make a key and save state as value state
            key = (char *)event->data.scalar.value;
	    s->keyname = key;
            //value = (char *)event->data.scalar.value;
            s->state = STATE_ACTION_VALUE;
            break;

        case YAML_MAPPING_END_EVENT:
	    s->actionlist.push_back( s->f);
	    s->f.clear();
            s->state = STATE_ACTIONVALUES;
            break;
        default:
            fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
            return FAILURE;
        }
        break;

    case STATE_ACTION_VALUE:
        switch (event->type) {
        case YAML_SCALAR_EVENT:
            temp = (char *)event->data.scalar.value;
	    if(s->keyname.empty()){
                std::cout << "cant have empty key " << std::endl;
                return FAILURE;
            }
            s->f.emplace(s->keyname, std::string(temp));
	    s->keyname.clear();
            s->state = STATE_ACTIONKEY;
            break;
        default:
            fprintf(stderr, "Unexpected event %d in state %d.\n", event->type, s->state);
            return FAILURE;
        }
        break;
    
    case STATE_STOP:
        break;
    }
    return SUCCESS;
}

int parse_config(parser_state *&state,std::string filename){
    int code;
    int status_;
    //struct parser_state state;
    //parser_state *state = new parser_state{};
    yaml_parser_t parser;
    yaml_event_t event;

    if (getenv("DEBUG")) {
        debug = 1;
    }
    FILE *fd = fopen(filename.c_str(), "r");
    if(!fd){
        std::cout << "Could not open file " << std::endl;
        return -1;
    }
    //memset(&state, 0, sizeof(state));
    state->state = STATE_START;
    yaml_parser_initialize(&parser);
    yaml_parser_set_input_file(&parser, fd);
    do {
        status_ = yaml_parser_parse(&parser, &event);
        if (status_ == FAILURE) {
            fprintf(stderr, "yaml_parser_parse error\n");
            code = EXIT_FAILURE;
            goto done;
        }
        status_ = consume_event(state, &event);
        if (status_ == FAILURE) {
            fprintf(stderr, "consume_event error\n");
            code = EXIT_FAILURE;
            goto done;
        }
        yaml_event_delete(&event);
    } while (state->state != STATE_STOP);

    /* Output the parsed data. */
    for (auto f : state->actionlist ) {
            std::cout << f["name"]<< std::endl;
    }
    code = EXIT_SUCCESS;

done:
    //destroy_actions(state->actionlist);
    yaml_parser_delete(&parser);
    //delete state;
    return code;
}

